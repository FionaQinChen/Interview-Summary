1、常用的异常类型?

Exception:异常层次结构的根类

ArithmeticException:算数错误情形，如以零做除数

ArrayIndexOutOfBoundsException:数组下标越界

NullPointerException:尝试访问null对象成员

ClassNotFoundException:不能加载所需的类

InputMismatchExcepion:欲得到的数据类型与实际输入的类型不匹配

IllegalArgumentExecption:方法接收到非法参数

ClassCastException:对象强制类型转换错误

NumberFormatException:数字格式转换异常

################################################################################################################################################################
2、session 和 cookie机制：

 由于HTTP协议是无状态的，而出于种种考虑也不希望使之成为有状态的，因此cookie机制采用的是在客户端保持状态的方案，
 而session机制采用的是在服务器端保持状态的方案。
 
 （cookie）
  正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie：
   cookie的内容主要包括：名字，值，过期时间，路径和域。 
  如果设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。 
 
 （session）
 session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 
    当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为session id，
    如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），
    如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，
    session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。
 保存这个session id的方式可以采用cookie。
 
 由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。
 经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面，
 附加方式也有两种，一种是作为URL路径的附加信息，另一种是作为查询字符串附加在URL后面。
 
 一般情况下，session都是存储在内存里，当服务器进程被停止或者重启的时候，内存里的session也会被清空，
 如果设置了session的持久化特性，服务器就会把session保存到硬盘上。
 
 1、session在何时被创建：
    直到某server端程序调用HttpServletRequest.getSession(true)这样的语句时才被创建；
 
 2、session何时被删除：
    a.程序调用HttpSession.invalidate();
    b.距离上一次收到客户端发送的session id时间间隔超过了session的超时设置;
    c.服务器进程被停止（非持久session）
    
####################################################################################################################################    

3、java锁

3.1.独享锁/共享锁：
  
  独享锁是指该锁一次只能被一个线程所持有。 (ReentrantLock、 Synchronized)
  共享锁是指该锁可被多个线程所持有。 (ReadWriteLock)
  
3.2.读写锁 ReentrantReadWriteLock：

  低16位代表写锁，高16位代表读锁

3.3.公平锁/非公平锁：

公平锁是指多个线程按照申请锁的顺序来获取锁。

非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能会造成饥饿现象。 

3.4.可重入锁：

可重入锁又名递归锁，是指同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。

3.5.乐观锁/悲观锁：

乐观锁/悲观锁不是指具体类型的锁，而是看待并发的角度。

悲观锁认为存在很多并发更新操作，采取加锁操作，如果不加锁一定会有问题

乐观锁认为不存在很多的并发更新操作，不需要加锁。数据库中乐观锁的实现一般采用版本号，Java中可使用CAS实现乐观锁。

################################################################################################################################

 4、GC原理：

  GC是垃圾收集的意思（GarbageCollection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，
Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。

  对于程序员来说，分配对象使用new关键字；释放对象时，只要将对象所有引用赋值为null，让程序不能够再访问到这个对象，我们称该对象为”不可达的”.
GC将负责回收所有”不可达”对象的内存空间。

################################################################################################################################

 5、HashMap原理：
  HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。
  
  Hashtable 是早期Java类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。

  HashMap与 HashTable主要区别在于 HashMap 不是同步的，支持 null 键和值等。HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选。

################################################################################################################################

 6、listlink arraylist 区别：
 
 1、ArrayList和LinkedList可想从名字分析，它们一个是Array(动态数组)的数据结构，一个是Link(链表)的数据结构，此外，它们两个都是对List接口的实现。

    前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列。

2、当随机访问List时（get和set操作），ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。

3、当对数据进行增加和删除的操作时(add和remove操作)，LinkedList比ArrayList的效率更高，
   因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。

4、从利用效率来看，ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；
   而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。

5、ArrayList主要控件开销在于需要在lList列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。

######################################################################################################################################################

7、AOP原理：（面向切面编程）

java的动态代理：动态生成一个代理类来调用被代理的对象。（个人理解）

动态代理的调用生成的对象是生成的是代理对象（userDaoProxy），而不是被代理的实现类（userDaoImpl）。

动态编译成一个代理对象的字节码，这个对象实现了和被代理类相同的接口。




 
 


 
 
 
